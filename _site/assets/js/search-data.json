{"0": {
    "doc": "Functions and Classes",
    "title": "Functions and Classes",
    "content": "{: .text-delta } 1. TOC {:toc} # Before you Begin ![Basics of Functions](images/functions_intro.png) ## Convention ```cpp #include void printMessage(); //note, this is placed BEFORE main() int main() { printMessage(); return 0; } //note, the definition is conventionally placed after main void printMessage() { std::cout int increment(int input); int main() { int a = 34; std::cout void increment(int &input); //Note the addition of '&' int main() { int a = 34; std::cout int main() { char operation = '*'; float input1 = 9.8; float input2 = 2.3; float result; calculate(input1, input2, operation, result); printEquation(input1, input2, operation, result); return 0; } void calculate(float in1, float in2, char op, float &ans); void printEquation(float input1,float input2, char operation, float result); void calculate(float in1, float in2, char op, float &ans) { switch(op) { case '+': ans = in1 + in2; break; case '-': ans = in1 - in2; break; case '*': ans = in1 * in2; break; case '/': ans = in1 / in2; break; default: std::cout using namespace std; class Trial { string trial_name; int trial_number; }; int main() { Trial trial_first; std::cout and which define which function is to be called either for getting a variable or setting the variable (this is why decorators are useful!) ![python_getter_setter](images/getter_python.png) **C++ Getters and Setters** ![c++_setter](images/getter_setter_cpp.png) ![c++_getter](images/c++_getter.png) ## Typical Class functionality ```cpp #include using namespace std; class Student { string name; int id; int gradDate; public: // setter methods which don't return anything // therefore are void types void setName(string nameIn); void setId(int idIn); void setGradDate(int dateIn); // getter methods which return a specific datatype // Note. they also don't need any inp params string getName(); int getId(); int getGradDate(); // print also only outputs from class directly // therefore void void print(); }; void Student::setName(string nameIn) { name = nameIn; } void Student::setId(int idIn) { id = idIn; } void Student::setGradDate(int gradDateIn) { gradDate = gradDateIn; } void Student::print() { cout using namespace std; //The cats class that we used earlier in the lesson. class Cats { string name; string breed; int age; public: Cats(); //declaring the constructor void setName(string nameIn); void setBreed(string breedIn); void setAge(int ageIn); string getName(); string getBreed(); int getAge(); void printInfo(); }; //defining the constructor Cats::Cats() { cout using namespace std; class Student { int grade[5]; int id; public: Student(); void setId(int idin); void setGrade(int index, int gradeIn); int getId(); int getGrade(int index); int getAvg(); void printInfo(); }; Student::Student() { for(int i=0;i #include \"Dog.cpp\" using namespace std; int main() { const int SIZE=3; Dog roster[SIZE]; roster[0].setName(\"Blue\"); roster[1].setName(\"King\"); roster[2].setName(\"Spot\"); printRoster(roster,SIZE); return 0; } // See here that we declare the roster as of type Dog instead of say: int roster[] void printRoster(Dog roster[], int size); void printRoster(Dog roster[], int size) { for(int i=0;ix = x; this->y = y; } }; int main() { Point p1(10,20); } ``` **Note. In the above code you may be wondering why the class name and the function name are the same. \\ This is becuase the public function Point is actually a constructor of the class. It will be called everytime we init the class and provide some arguments. See [Overloading Constructors](#overloading-constructors) section for further information. ### Case 2: To return a reference to the class object and chain calls - As we learnt, `this` is a reference to each class object applied to non-static variables/member funcs (This is because static vars are common to each class btw, obviously explained in the video above pls watch) - Also note from the pointers chapter, if `float x = 3;`, then just `x;` would call the variable value - But `&x` would return the address of x. Therefore `&` is the return type modifier. We see this used below ![chaining_calls](images/this_pointer_use.png) ____________________________________________________________________________________________________________________________________ # Overloading Functions Assume you have the following scenario: ```cpp #include int findSmallerInt(int input1, int input2); float findSmallerFloat(float input1, float input2); int main() { int a = 5; int b = 4; float f1 = 5.43; float f2 = 6.32; char c1 = 'c'; char c2 = 'z'; std::cout //C++ allows us to 'overload' the same function name as long as //the variable types in the function inputs are different. class Compare { public: int findSmaller(int input1, int input2); float findSmaller(float input1, float input2); char findSmaller(char input1, char input2); int findSmaller(int input1, int input2, int input3); float findSmaller(float input1, float input2, float input3); char findSmaller(char input1, char input2, char input3); int findSmaller(int arrayIn[], int size); float findSmaller(float arrayIn[], int size); char findSmaller(char arrayIn[], int size); }; int Compare::findSmaller(int input1, int input2) { if(input1 arrayIn[j + 1]) { int temp = arrayIn[j]; arrayIn[j] = arrayIn[j + 1]; arrayIn[j + 1] = temp; } } return arrayIn[0]; } float Compare::findSmaller(float arrayIn[], int size) { { for (int i = 0; i arrayIn[j + 1]) { float temp = arrayIn[j]; arrayIn[j] = arrayIn[j + 1]; arrayIn[j + 1] = temp; } } return arrayIn[0]; } char Compare::findSmaller(char arrayIn[], int size) { { for (int i = 0; i arrayIn[j + 1]) { int temp = arrayIn[j]; arrayIn[j] = arrayIn[j + 1]; arrayIn[j + 1] = temp; } } return arrayIn[0]; } ``` ## Overloading Constructors Now, it's nice to have a class with different options for constructing the object of the class We can do the following: ```cpp //header file for main.hpp #include #include using namespace std; class Square { private: int length; int width; public: Square(); Square(int lenIn, int widIn); int getLength(); int getWidth(); }; Square::Square() { length = 0; width = 0; } Square::Square(int lenIn, int widIn) { length = lenIn; width = widIn; } int Square::getLength() { return length; } int Square::getWidth() { return width; } //______________________________________________________________// #include \"main.hpp\" int main() { Square s1; Square s2(4,3); cout using namespace std; class Shape { private: int length; // Length of a box int width; public: // Constructor definition Shape(int l = 2, int w = 2) { length = l; width = w; } int getWidth() { return width; } int getLength() { return length; } double Area() { return length * width; } // class function which performs the operator overloading int operator +(Shape shapeIn) { return ((width + shapeIn.getWidth())*(length + shapeIn.getLength())); } }; ``` main file(.cpp) ```cpp int main(void) { Shape sh1(4, 4); // Declare shape1 Shape sh2(2, 6); // Declare shape2 Shape sh3; //Declare shape3 // the operator overloading (we are literally adding two objects of different type) int total = sh1 + sh2; cout using namespace std; //Our generic function template //tell the compiler we are using a template T findSmaller(T input1,T input2); int main() { int a = 54; int b = 89; float f1 = 7.8; float f2 = 9.1; char c1 = 'f'; char c2 = 'h'; string s1 = \"Hello\"; string s2 = \"Bots are fun\"; //Wow! We can use one function for different variable types cout T findSmaller(T input1,T input2) { if(input1 < input2) return input1; else return input2; } ``` ![](/images/cpp_templates.png) ",
    "url": "/Functions_and_Classes",
    "relUrl": "/Functions_and_Classes"
  },"1": {
    "doc": "Intro",
    "title": "Intro",
    "content": "For Jekyll reference see [just_the_docs](https://pmarsceill.github.io/just-the-docs/) To deploy on heroku follow the steps in the link below (and use the gem files, rake files and proc files in this repo for reference) The following files will need to be copied from this repo: - config.ru - Rakefile - Procfile - static.json - config.yaml (only the differences) And only if necessary: - Gemfile - Gemfile.lock - remove _sites from .gitignore Run bundle exec jekyll serve after making the above changes After copying these files (or their necessary contents), install heroku cli and do: ```bash heroku login ``` Then do heroku create as per the below link and the other steps necessary (git push heroku master) [Deploy jekyll on heroku](https://blog.heroku.com/jekyll-on-heroku) Finally, go to heroku page -> settings -> change the name of the app and find the url # To better your experience of writing in code Download the following extensions in vscode: 1. Markdown All in one 2. code runner (see youtube video on how to setup vscode for C++) # Shortcuts in general pour toi - Once Markdown all in one is installed, you can do **ctrl+shift+v** to see preview of markdown immediately - To run any C++ file it's just **ctrl+shift+n** - If you want to bold any specific text in markdown just select the text by holding down **ctrl+shift** and using arrow keys to select the required text. Then once text is selected just do **ctrl+b** to **bolden** and **ctrl+i** to ***italicize*** - click on tab after using **-** for normal bullet pointing to get sub-points - To get numbered list continuously, in-between two headings 1. and 2. all content should be indented with 4 spaces in the markdown script - To shift between windows in ubuntu, just do **windows_key+shift+right/left_arrow** - To minimize or unmaximize any window in **hold down alt and press space**, then choose to minimize - To then maximize or move window to right half/left half of screen, **windows_key+shift+right/left_arrow** ",
    "url": "/intro/",
    "relUrl": "/intro/"
  },"2": {
    "doc": "Basics",
    "title": "Basics",
    "content": "{: .text-delta } 1. TOC {:toc} ## Basics to Begin - To only compile files on the command line: g++ -o HelloWorld hello.cpp (where hello.cpp was the C++ code you wrote) ## Objects and Variables In C++, direct memory access is not allowed. Instead, we access memory indirectly through an object. An object is a region of storage (usually memory) that has a value and other associated properties. The key point here is that rather than say go get the value stored in mailbox number 7532, we can say, go get the value stored by this object. This means we can focus on using objects to store and retrieve values, and not have to worry about where in memory they’re actually being placed. ### Best practice for variables 1. Declaration ```cpp int a, double b; // wrong (compiler error) int a; double b; // correct (but not recommended) // correct and recommended (easier to read) int a; double b; ``` Although the language allows you to do so, avoid defining multiple variables in a single statement (even if they are the same type). Instead, define each variable in a separate statement (and then use a single-line comment to document what it is used for). 2. Initializations C++ offers a form of initialization called brace initialization. **Favor initialization using braces whenever possible.** ```cpp int width = 5; // copy initialization of value 5 into variable width int width { 5 }; // direct brace initialization of value 5 into variable width (preferred) // you could also not initialize in cases where value is going to change immediately int x {}; // value initialization std::cin >> x; // we're immediately replacing that value int a, b = 5; // wrong (a is not initialized!) int a = 5, b = 5; // corr ``` # Intro to iostream ![General format of headers](/images/cpp_headers.png) Note how the iostream is inside quotes here. That says that iostream is present in the present working directory and the compiler has to look there 1. Concatenation in std::cout To print more than one thing on the same line, the insertion operator ( // for std::cout int main() { std::cout // for std::cout and std::endl int main() { std::cout // for std::cout int main() { int x{ 5 }; std::cout > x; // get number from keyboard and store it in variable x std::cout // for std::cout and std::cin int main() { std::cout > x >> y; // get two numbers and store in variable x and y respectively std::cout std::pow(base, exponent); M_PI = 3.14 //it has more decimal places not shown here // M_PI is a standard variable of the cmath library ``` ## Weird Implicit conversions Check out the following code: ```cpp #include int main(void) { int numerator = 4; int denominator = 5; float answer = numerator / denominator; std::cout int main(void) { float numerator = 4; float denominator = 5; float answer = numerator / denominator; std::cout int main() { int n1 = 1; int n2 = ++n1; int n3 = ++ ++n1; int n4 = n1++; // int n5 = n1++ ++; // error // int n6 = n1 + ++n1; // undefined behavior std::cout << \"n1 = \" << n1 << '\\n' << \"n2 = \" << n2 << '\\n' << \"n3 = \" << n3 << '\\n' << \"n4 = \" << n4 << '\\n'; } ``` The output for the above is: ```bash n1 = 5 n2 = 2 n3 = 4 n4 = 4 ``` ",
    "url": "/Basics",
    "relUrl": "/Basics"
  },"3": {
    "doc": "Control Flow",
    "title": "Control Flow",
    "content": "{: .text-delta } 1. TOC {:toc} # Before you Begin To create an array we need to use [] as shown in the example below: ```cpp #include #include int main() { //instead of printing 0 and 1, create an array where //0 = False, 1 = True std::string TorF[] = {\"False\", \"True\"}; int a = 100; int b = 33; int c = 33; //Print out the string values of each relational operation std::cout b is \"b]; std::cout= b is \"=b]; std::cout b is True a != b is True c >= b is True c >location; std::cout<<location<<\"\\n\"; //Use if-else statements to control program flow //note that the curly braces are not necessary if there is only //one line of code. if(location == 'w') std::cout<<\"Get a fish\"<<\"\\n\"; } ``` ## Switch Case Basic Syntax: ```cpp switch(menuItem) { case(1): std::cout<<\"Skiing?! Sounds dangerous!\\n\"; break; case(2): std::cout<<\"Sledding?! Sounds like work!\\n\"; break; case(3): std::cout<<\"Sitting by the fire?! Sounds warm!\\n\"; break; case(4): std::cout<<\"Hot chocolate?! Yum!\\n\"; break; default: std::cout<<\"Enter a valid menu item\"; } ``` If the break statement is not specified (which still works), the next cases after the selection will cascade and be executed Another example ```cpp void calculate(float in1, float in2, char op, float &ans) { switch(op) { case '+': ans = in1 + in2; break; case '-': ans = in1 - in2; break; case '*': ans = in1 * in2; break; case '/': ans = in1 / in2; break; default: std::cout<<\"Illegal operation\\n\"; } } ``` # Loops 1. Simple init, condition, increment **for loops**: ```cpp int main() { for(int i=0; i< 10;i++) { std::cout<<\"i = \"<<i<<\"\\n\"; } return 0; } ``` 2. **While loops** ```cpp while(entry <=5) { std::cout<<\"incrementing entry = \"<<entry<<\"\\n\"; entry++; } ``` 3. Do While Loops (these execute before checking condition) ```cpp do { std::cout<<\"Count = \"<<count<<\"\\n\"; count++; }while(count < 5); ``` ",
    "url": "/Control_Flow",
    "relUrl": "/Control_Flow"
  },"4": {
    "doc": "Files, User IO and Variables",
    "title": "Files, User IO and Variables",
    "content": "{: .text-delta } 1. TOC {:toc} ## Some Distinct Variable Types 1. Constant variables These are immutable types are defined as shown below: ```cpp const int weightGoal = 100; ``` 2. Enumerated constants We are given the option of creating a variable which can hold only a finite number of values **the enum class acts as a constructor object with a specific set of values only** ```cpp int main() { //define MONTHS as having 12 possible values enum MONTHS {Jan, Feb, Mar, Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec}; //define bestMonth as a variable type MONTHS MONTHS bestMonth; //assign bestMonth one of the values of MONTHS bestMonth = Jan; //now we can check the value of bestMonths just //like any other variable if(bestMonth == Jan) { cout std::cout** library Basic steps: - Include the library - Create a stream (input, output, both) - ofstream myfile; (for writing to a file) - ifstream myfile; (for reading a file) - fstream myfile; (for reading and writing a file) - Open the file myfile.open(“filename”); - Write or read the file - Close the file myfile.close(); During some file handling ops you may see **ios::app** mentioned during file opening \\ This ios is the base class for fstream, ofstream and ifstream (you don't need to worry about it) ```cpp #include #include #include using namespace std; int main () { string line; fstream fio; //create an output stream to write to the file //append the new lines to the end of the file fio.open(\"input.txt\", ios::out | ios::in); if (fio) { fio.seekg(0, ios::end); fio #include using namespace std; ``` Now we will use that info to figure out *what to do* in the main program: ```cpp #include \"trial_header.hpp\" int main() { cout ` - Use getline and cin as shown above to get string from user \\ ` std::getline(std::cin, stringVariable) ` - Convert the string variable to a float variable \\ ` std::stringstream(stringVariable) >> numericVariable ` ## Differnt ways to taking User Input ### Case Study: Taking User input and converting the input string to float ```cpp #include #include #include using namespace std; int main() { string length; string width; float length_numeric; float width_numeric; double area; cout > length_numeric; cout > width_numeric; area = length_numeric*width_numeric; cout >guess; std::cout>givenInt; std::cout>givenFloat; std::cout>givenDouble; //We need to use cin.ignore so cin will ignore //the characters in the buffer leftover //from the givenDouble std::cin.ignore(); std::cout>givenChar; std::cout #include int main() { int userInput[40]; //Enter the numbers into an array called userInput for(int i = 0; i < 40; i++) { scanf(\"%d\", &userInput[i]); } } ``` ",
    "url": "/File_ops",
    "relUrl": "/File_ops"
  },"5": {
    "doc": "General Troubleshooting",
    "title": "General Troubleshooting",
    "content": "{: .text-delta } 1. TOC {:toc} # C++ Helper Guide ## Basics to Begin ### Simple way - To only compile files on the command line: g++ -o HelloWorld hello.cpp (where hello.cpp was the C++ code you wrote) - To run a compiled file you can do: ```bash ./HelloWorld ``` ### Alterantive - You could also do: g++ main.cpp -o main.out - Then to run the code do: ./main.out ## Troubleshooting 1. When executing a program if the console window blinks and closes immediately ```cpp #include #include | // then at the end of your main function (before return statement) std::cin.clear(); // reset any error flags std::cin.ignore(std::numeric_limits::max(), '\\n'); // ignore any characters in the input buffer until we find an enter character std::cin.get(); // get one more char from the user ``` 2. Error: unresolved external symbol _main or _WinMain@16 This means your compiler can’t find your main() function. All programs must include a main() function. # Useful Links ![lvalue_rvalue](https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/) ",
    "url": "/General_troubleshooting",
    "relUrl": "/General_troubleshooting"
  },"6": {
    "doc": "Git Concepts",
    "title": "Git Concepts",
    "content": "{: .text-delta } 1. TOC {:toc} # Before you Begin {: .fs-9 } [Reference](https://www.w3schools.com/git/git_getstarted.asp?remote=github){: .btn .fs-5 .mb-4 .mb-md-0} In the above link, follow the procedures, but instead of using username and password each time, setup the ssh keys and use them more often *ssh keys are found in ./.ssh folder (or lookup keygen to generate your keys)* # Basics of generating new content in local and pushing to github ## Process for adding to a github page git add . \\ git commit -m \"made new code\" \\ git push or git push origin develop (if you cloned from develop branch) ## If you want to track a different branch - git branch --set-upstream-to=origin/master \\ git add . \\ git push or make a new remote - git remote add ts_origin_wiki git@github.com:sjayanth21/BR_Wiki.git \\ git push --set-upstream ts_origin_wiki master \\ git push ts_origin_wiki_master ## Working with remotes Any folder can have a number of remotes like: origin and ts_origin_github To make local branch master track a different remote branch (branch in your cloud github repo) do: git branch --set-upstream-to=origin/master or git branch --set-upstream-to=origin/develop ## If you cloned a repo, forked your own branch (using git checkout) You may need to pull from upstream to update your codebase \\ However, running a simple 'git pull' may throw merge conflicts So do the following 1. Run a 'git fetch' to get the updates on all branches (and if any new branch has been added) 2. In your personal branch commit all changes by doing: git add, commit and push 3. sudo apt install meld 4. Now to get the upstream updates do 'git checkout develop' (whichever is the main branch) 5. Now to put this in your personal branch run 'git checkout feature/sj' 6. Now we do the actual merging using 'git merge develop' (this will merge everythin in deveop into the current branch viz feature/sj) 7. The above step would have thrown some merge conflicts, to solve that run 'git mergetool' 8. The above step opens meld, make all necessary resolutions and save 9. Now our codebase would have been updated to whatever we resolved in meld 10. Now run 'git commit' without any arguments as it is a 'merge commit' 11. Now as usual do 'git push origin feature/sj' to push your updated personal branch to github ## Points to Note - If you checkout a file 'git checkout blade.py' it resets the file to whatever is the latest from that branch in upstream - If you want to physically add or change remotes go to the respective folder and do 'nano .git/config' - the correct syntax for the merge command is: \\ 'git merge ts_origin/master' \\ What this does is that if the current branch is origin/develop it will merge the files of \\ current branch i.e origin/develop with ts_origin/master - Note that even if ts_origin/master is in ts_github account and origin/master is in sushanthj github account, it will still merge as long as remotes exist for both these accounts. If remotes don't exist, you can always add as shown up above ### Concepts for working with two repos or two repos on two different github accounts: Basically locally you will have 'master' branch if you do 'git branch' \\ This master can track two upstream branches using two different remotes \\ One remote is added automatically when you clone the repo \\ The next remote will have to be added manually to your other git account or other repo Then to push the same commit to both branches first do 'git push' \\ and see which repo it pushes to (say it pushes to origin/master \\ Then do 'git push --set-upstream ts_origin/develop' to push to your second repo \\ However, do note that your local branch always tracks to the latest branch you pushed to \\ i.e if you do a git pull, it will pull from the latest branch to which you pushed \\ in this case it will pull from ts_origin/develop ### Saving a patch file If you have changes made which you want to save locally and not push to remote, you can save a patch file ```bash git diff > new_changes.patch ``` Now to apply this patch onto any branch, do: ```bash git apply new_changes.patch ``` ### Saving changes by stashing Instead of saving a specific file for changes (such as a patch file), you could also stash your changes locally ``` git stash ``` The above command will stash all tracked changes. You could also stash only committed changes. Refer: [stashing](https://www.atlassian.com/git/tutorials/saving-changes/git-stash) To then apply the stashed changes (one time use only as pop will remove from stash) ``` git stash pop ``` To apply without popping do: ``` git stash apply ``` To remove any particular item in stash: ``` git stash drop ``` To view all entries in stash and then apply specific one do: ``` git stash list git stash apply n ``` n = stash item number ",
    "url": "/git_concepts",
    "relUrl": "/git_concepts"
  },"7": {
    "doc": "Heaps",
    "title": "Heaps",
    "content": "{: .text-delta } 1. TOC {:toc} **This is a starter to learn about min heaps and priority queues**. To learn more [Ref Video](https://www.youtube.com/watch?v=hOjcdrqMoQ8&ab_channel=NeetCode) # Non-optimized approach to search (vectors) - Sort the input array so that we can search for any number in log(n) time (Binary Search) - However, adding any new element into the sorted array with O(n) time - Therefore it doesn't seem too optimal. Could there be something better? # Optimal approach (Heaps) Here we'll specifically use a Min heap. These have **kinda sorted properties**. **The advantage of heaps over vectors/arrays is** - We can add and pop elements in log(n) time vs the O(n) time with vectors - **We can get min value of min_heap in O(1)** which is definitely better than an unsorted array - Also, we only need a min heap because we need only the kth largest values in heap and we don't care about other elements. Also we'll never be removing elements, just adding them again and again. - **Therefore all we need is a min-heap of size K** - We'll essentially keeping popping the min element of the heap until heap is of size K ## Summary - Heap is just like a vector (in that it's unsorted), but it can give min value in log(n) time - Usually stacks are preferred over heaps since they are faster and have easier memory access - Heaps are implemeneted from full binary trees ### Lessons Learnt 1. How is a heap better than a vector 2. How to use a heap in C++ [Ref](https://www.geeksforgeeks.org/heap-using-stl-c/) # Working with Heaps in C++ 1. Creation of heap from a list type container (officially called range container): ```cpp // Initializing a vector vector v1 = {20, 30, 40, 25, 15}; // Converting vector into a heap // using make_heap() make_heap(v1.begin(), v1.end()); ``` 2. Getting max element of a max heap \\ The max element of a heap = Front of heap i.e. ```v1.front()``` 3. To define a min heap is a bit tricky in C++. We need to use priority queue (part of `````` library) which uses min_heap in background 4. **Efficiently Init a priority_queue from a vector (but works only for max heap :/)** ```cpp int main() { int arr[] = { 15, 25, 6, 54, 45, 26, 12 }; int N = sizeof(arr) / sizeof(arr[0]); // Initialize priority_queue priority_queue pq(arr, arr + N); // print individual elements while (!pq.empty()) { // Print the element cout class KthLargest { private: int k; public: priority_queue , greater > min_heap; KthLargest(int k, vector& nums) { this->k = k; // add all elements in vector to heap for(int i = 0; i k) min_heap.pop(); } int add(int val) { // add new val to heap whatever the case min_heap.push(val); // after adding new val we need to resize the heap // so that we still have kth largest elements only // therefore, to make space we again pop the min element if(min_heap.size() > this->k) min_heap.pop(); return min_heap.top(); } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj->add(val); */ ``` **Note. Using this variable makes life easy here (think of this->k as self.k in python)** - We've added a private variable ```int k``` (which is usually not there in leetcode). - The reason is that we need the k value to be accessed by a member function ```int add``` - Therefore, it needs to be declared as a local class variable (like self in python) - To make it a local variable, we need to put it under the private declaration. ## Another example of Heaps (Max Heap derived from Vectors here) This is a starter to learn about max_heaps (without using priority queues) ![](/images/last_stone.png) ### My C++ Solution ```cpp #include class Solution { public: int lastStoneWeight(vector& stones) { // init placeholder for max and 2nd max value of heap int max1 = 0; int max2 = 0; // init a heap from the given vector make_heap(stones.begin(), stones.end()); // alternative way of making heap is to use priority queue // priority_queue > max_heap; // for(int i=0; i 1) { // extract first largest ('y' in problem statement) max1 = stones.front(); cout << max1; // remove from heap first pop_heap(stones.begin(), stones.end()); // remove from vector stones.pop_back(); // extract second largest ('x' in problem statement) max2 = stones.front(); cout << max2; // remove from heap first pop_heap(stones.begin(), stones.end()); // remove from vector stones.pop_back(); // if equal don't do anything as both elements have been popped if ((max1 == max2) && stones.size() != 0) continue; else if ((max1 == max2) && stones.size() == 0) { stones.push_back(0); } // if not equal then reduce y and add it back else { max1 = max1-max2; // add to vector first stones.push_back(max1); // reorder heap after new addition push_heap(stones.begin(), stones.end()); } } return stones.front(); } }; ``` ",
    "url": "/Heaps",
    "relUrl": "/Heaps"
  },"8": {
    "doc": "Home",
    "title": "Home",
    "content": "# C++ tutorials {: .fs-9 } [Courseware](https://www.learncpp.com/cpp-tutorial/statements-and-the-structure-of-a-program/){: .btn .fs-5 .mb-4 .mb-md-0 } ",
    "url": "/",
    "relUrl": "/"
  },"9": {
    "doc": "Pointers & Arrays",
    "title": "Pointers & Arrays",
    "content": "{: .text-delta } 1. TOC {:toc} # Before you Begin Bjourne says that pointers should be used judiciously since they may make computation slowly due to dereferncing and other activities of pointers. Also, they should be abstracted at higher levels so that it becomes easy to read code. Basically pointers should be hidden away well at higher levels. ![pointers](/images/pointers.png) # Deferencing of Pointers - This is the act of accessing the value stored at the location which the pointer is pointing to. - This act is represented by the `*` operator ![deferencing_pointers](/images/deferencing_pointers.png) **In the above image we can see that:** - **pointerToA = address value** - ***pointerToA = value (deferenced)** Another example to illustrate: ```cpp /*For this program print for each variable **print the value of the variable, **then print the address where it is stored. */ #include #include int main() { int givenInt; std::string givenString; char givenChar; //printing the values of each of these variables std::cout #include int main() { std::string name; int givenInt; float givenFloat; double givenDouble; std::string givenString; char givenChar; int *pointerGivenInt; int **pointerPointerGivenInt; pointerGivenInt = &givenInt; pointerPointerGivenInt = &pointerGivenInt; //Get the values of each variable std::cout>givenInt; std::cout>givenFloat; std::cout>givenDouble; //We need to use cin.ignore so cin will ignore //the characters in the buffer leftover //from the givenDouble std::cin.ignore(); std::cout>givenChar; std::cout int main() { int userInput = 0; int maxNumber = 0; int minNumber = 100; int sumTotal = 0; float average = 0; //get the numbers from the user for(int i = 0; i >userInput; std::cout maxNumber) { maxNumber = userInput; } if(userInput #include int main() { int userInput[40]; //Enter the numbers into an array called userInput for(int i = 0; i = 0; i--) { std::cout #include int main() { int searchKey = 0; int searchArray[10] = {324,4567,6789,5421345,7,65,8965,12,342,485}; int location = 0; while(1) { std::cout #include //Pass the array as a pointer void arrayAsPointer(int *array, int size); //Pass the array as a sized array void arraySized(int array[3], int size); //Pass the array as an unsized array void arrayUnSized(int array[], int size); int main() { const int size = 3; int array[size] = {33,66,99}; //We are passing a pointer or reference to the array //so we will not know the size of the array //We have to pass the size to the function as well arrayAsPointer(array, size); arraySized(array, size); arrayUnSized(array, size); return 0; } void arrayAsPointer(int *array, int size) { std::cout<<std::setw(5); for(int i=0; i<size; i++) std::cout<<array[i]<<\" \"; std::cout<<\"\\n\"; } void arraySized(int array[3], int size) { std::cout<<std::setw(5); for(int i=0; i<size; i++) std::cout<<array[i]<<\" \"; std::cout<<\"\\n\"; } void arrayUnSized(int array[], int size) { std::cout<<std::setw(5); for(int i=0; i<size; i++) std::cout<<array[i]<<\" \"; std::cout<<\"\\n\"; } ``` # Multidimensional Arrays To create a 2x3 array you just need to do: `int array2d[2][3];` You could also initialize them with: `int array2D[2][3] = {0,1,2,3,4,5};` But this will initialize it in the row-major order, i.e.: - [0][0] - [0][1] - [0][2] - [1][0] - [1][1] - [1][2] ",
    "url": "/Pointers_and_Arrays",
    "relUrl": "/Pointers_and_Arrays"
  },"10": {
    "doc": "Sets and Maps",
    "title": "Sets and Maps",
    "content": "{: .text-delta } 1. TOC {:toc} # Intro to Sets In C++ the STL library has sets and unordered sets: - ```#include ``` - is by default an ordered set - ```#include ``` Internally, the elements of a set are organized into buckets and uses **hashing** to insert elements into buckets. This makes it have constant time complexity! ## Simple set example ```cpp #include #include #include #include using namespace std; int main() { // to force keep in descending order //set Set; // Leaving it in ascending order set Set = {1,2,3,4,1,2,3,4} for(const auto& e: Set) { cout #include #include #include using namespace std; class Person { public: float age; string name; bool operator Set = { {30,\"John\"},{25,\"Taylor\"},{22,\"Steve\"}}; for(const auto& e: Set) { cout #include #include #include int main() { std::multiset> multiset = {5,3,4,2,45,1} for(const auto& e: multiset) { cout ``` or ```std::less``` for ascending or descending respectively ## Unordered Set Uses hashing while the ordered set using Red-Black-Tree as backend datastructure. The syntax for an unordered set is similar though as shown here: ```cpp #include #include #include #include int main() { std::unordered_set> uset = {5,3,4,2,45,1} for(const auto& e: multiset) { cout #include #include #include int main() { std::map> Map; // Two methods to initialize Map[\"John\"] = 1002; Map.insert(std::make_pair(\"Bot\", 1111)); // Looping through map for(const auto &e: Map) { cout #include #include #include using namespace std; int main() { std::multimap Map; // WE CANNOT DO THIS ANYMORE BECAUSE OF AMBIGUITY // Map[\"John\"] = 1002; // Map[\"John\"] = 1003; Map.insert(std::make_pair(\"Bot\", 1111)); // Get all paris of a given key auto range = Map.equal_range('a'); for(auto it = range.first; it != range.second; ++it) { cout first second ::iterator, map::iterator> it; // define the iterator it = Map.equal_range(\"Bot\") // print the bounds of the first and second pairs in iterator cout first second; cout first second; return 0; ``` As seen above, each iterator has it's own range - First iterator upper-to-lower = lower bound - Second iterator upper-to-lower = upper bound All this drama of defining two iterators and their type is handled by using the ```auto``` type inference [Reference](https://www.geeksforgeeks.org/type-inference-in-c-auto-and-decltype/) ## Unordered Maps Major difference here is that: | Map | Unordered Map |:---------------------------------------|:-------------------------------------| Uses Red-Black-Tree backend datastruct | Uses buckets & hashing for backend DS| ```cpp #include #include #include #include using namespace std; int main() { std::unordered_map umap = { {\"bob\",2}, {\"john\",3}}; return 0; } ``` ",
    "url": "/Sets_and_maps",
    "relUrl": "/Sets_and_maps"
  },"11": {
    "doc": "Stacks",
    "title": "Stacks",
    "content": "## Refresher - Stacks are FIFO methods - queues are FILO methods - deques allow for insertion in front or end and popping in front or end # Toy Problem ```cpp #include #include using namespace std; int main() { stack stack; stack.push(21);// The values pushed in the stack should be of the same data which is written during declaration of stack stack.push(22); stack.push(24); stack.push(25); int num=0; stack.push(num); stack.pop(); stack.pop(); stack.pop(); while (!stack.empty()) { cout << stack.top() <<\" \"; stack.pop(); } } ``` Output: ``` 22 21 ``` ",
    "url": "/Stacks",
    "relUrl": "/Stacks"
  },"12": {
    "doc": "Vectors",
    "title": "Vectors",
    "content": "{: .text-delta } 1. TOC {:toc} # Intro Similar to how we were using the STL library for I/O, string etc, we will now use another part of this STL library for object oriented classes **Vector class falls under such an object oriented class** To instatiate a vector one must do: ```cpp std::vector vectorInts; ``` - The vector has size 0 on instantiation - We can *resize* it to change size of vector ```cpp // constructing vectors #include #include //Need to include the vector library! int main () { //creating a vector of integers std::vector vectorInts; std::cout::iterator it; for (it = vectorInts.begin(); it != vectorInts.end(); ++it) std::cout int main () { //TODO: create a vector of floats std::vector vFloat; std::cout vFloat2(10, 8.8); std::cout #include using namespace std; // function declaration void printVector(vector vIn); // function definition void printVector(vector vIn) {//printing the contents of vIns //TODO: Complete the function std::vector::iterator it; for(it = vIn.begin(); it != vIn.end(); ++it) { std::cout #include int main () { //creating a vector of integers (currently has zero elements) std::vector vectorInts; //creating an iterator for the vector std::vector::iterator it; std::cout #include int main () { //creating a vector of integers std::vector vectorInts; //creating an iterator for the vector std::vector::iterator it; vectorInts.push_back(0); vectorInts.push_back(1); vectorInts.push_back(2); vectorInts.push_back(3); vectorInts.push_back(4); vectorInts.push_back(5); vectorInts.push_back(6); vectorInts.push_back(7); //printing the contents of vectorInts std::cout::iterator it``` 2. Set the iterator to the index you want: ```it = vectorInts.begin() + 1``` 3. Do the insertion: ```vectorInts.insert(it, -1)``` ### Emplace vs Insert - Insert adds the new element to the next position of the iterator - Whereas empace adds it to that position of the iterator itself ```cpp //insert an element after the first element it = vectorInts.begin() + 1; vectorInts.emplace(it, -1); ``` Check out this for more reference: [REF](https://stackoverflow.com/questions/14788261/c-stdvector-emplace-vs-insert) ## Removing from an array ### vector.clear() Removes all elements from array ```cpp //clear the vector vectorInts.clear(); ``` ### vector.erase() - Remove a single element from a vector ```cpp //erase the 5th element in the vector vectorInts.erase(vectorInts.begin()+4); ``` - Remove a range of values: ```cpp //erase a range of elements in the vector vectorInts.erase(vectorInts.begin()+1, vectorInts.begin()+3); ``` ### vector.pop_back(): ```cpp //pop the last element off the vector vectorInts.pop_back(); ``` Note.pop_back() has no return value! The below code will not compile ```cpp int a; a = vectorInts.pop_back(); //this line does not compile ``` ",
    "url": "/vectors",
    "relUrl": "/vectors"
  }
}
